name: Deploy to Production

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., v1.2.3)'
        required: true
        type: string

env:
  NODE_VERSION: '20'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  ENVIRONMENT: production

jobs:
  # Run Full CI Pipeline First
  ci-checks:
    name: Run CI Checks
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  # Build and Push Docker Image
  build-and-push:
    name: Build & Push Production Image
    runs-on: ubuntu-latest
    needs: [ci-checks]
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Deploying version: ${VERSION}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}},value=${{ steps.version.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ steps.version.outputs.version }}
            type=raw,value=production-latest
            type=sha,prefix=prod-

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            VERSION=${{ steps.version.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-latest
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom-production
          path: sbom.spdx.json
          retention-days: 90

      - name: Sign container image
        if: ${{ secrets.COSIGN_PRIVATE_KEY != '' }}
        run: |
          echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key
          cosign sign --key cosign.key ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}

  # Upload Sourcemaps to Sentry
  sentry-release:
    name: Create Sentry Release
    runs-on: ubuntu-latest
    needs: [build-and-push]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}

      - name: Create Sentry release
        run: |
          VERSION="${{ needs.build-and-push.outputs.version }}"
          npx @sentry/cli releases new "${VERSION}"
          npx @sentry/cli releases set-commits "${VERSION}" --auto
          npx @sentry/cli releases files "${VERSION}" upload-sourcemaps .next
          npx @sentry/cli releases finalize "${VERSION}"
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}

  # Deploy to Production (Manual Approval Required)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, sentry-release]
    environment:
      name: production
      url: https://servicedesk.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment backup
        run: |
          echo "Creating backup before deployment..."
          # Backup logic here (database, configs, etc.)

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: ${{ secrets.AWS_ACCESS_KEY_ID != '' }}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to ECS (AWS)
        if: ${{ secrets.AWS_ACCESS_KEY_ID != '' }}
        run: |
          # Update ECS service with new image
          aws ecs update-service \
            --cluster servicedesk-production \
            --service servicedesk-app \
            --force-new-deployment \
            --task-definition servicedesk-production:${{ needs.build-and-push.outputs.version }}

          # Wait for deployment to complete
          aws ecs wait services-stable \
            --cluster servicedesk-production \
            --services servicedesk-app

      - name: Deploy to Kubernetes
        if: ${{ secrets.KUBE_CONFIG_PROD != '' }}
        run: |
          # Setup kubectl
          echo "${{ secrets.KUBE_CONFIG_PROD }}" | base64 -d > kubeconfig
          export KUBECONFIG=./kubeconfig

          # Update deployment with new image
          kubectl set image deployment/servicedesk-app \
            servicedesk-app=${{ needs.build-and-push.outputs.image-tag }} \
            -n production

          # Wait for rollout to complete
          kubectl rollout status deployment/servicedesk-app -n production --timeout=10m

          # Verify all pods are running
          kubectl get pods -n production -l app=servicedesk-app

      - name: Deploy via SSH (VPS/VM)
        if: ${{ secrets.PROD_SSH_HOST != '' }}
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: ${{ secrets.PROD_SSH_PORT || 22 }}
          script: |
            cd /opt/servicedesk
            docker-compose pull
            docker-compose up -d --force-recreate --no-deps servicedesk-app
            docker system prune -f

      - name: Run database migrations
        run: |
          # Run migrations (adjust based on your deployment method)
          echo "Running database migrations..."
          # kubectl exec -n production deployment/servicedesk-app -- npm run migrate:run

      - name: Notify Sentry of deployment
        run: |
          npx @sentry/cli releases deploys "${{ needs.build-and-push.outputs.version }}" new -e production
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}

  # Production Smoke Tests
  smoke-tests:
    name: Production Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-production]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Wait for deployment to stabilize
        run: sleep 60

      - name: Health check
        run: |
          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            response=$(curl -f -s -o /dev/null -w "%{http_code}" ${{ secrets.PROD_URL }}/api/health)
            if [ $response -eq 200 ]; then
              echo "Health check passed: $response"
              exit 0
            fi
            echo "Health check attempt $((RETRY_COUNT+1)) failed with status: $response"
            RETRY_COUNT=$((RETRY_COUNT+1))
            sleep 10
          done

          echo "Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Run critical path tests
        run: |
          npx playwright test --grep @critical
        env:
          PLAYWRIGHT_BASE_URL: ${{ secrets.PROD_URL }}

      - name: Verify API endpoints
        run: |
          # Test critical endpoints
          curl -f ${{ secrets.PROD_URL }}/api/health || exit 1
          curl -f ${{ secrets.PROD_URL }}/api/auth/status || exit 1
          echo "All critical endpoints responding"

      - name: Check error rates
        run: |
          # Query monitoring system for error rates
          echo "Checking error rates in production..."
          # Add your monitoring check here (Datadog, New Relic, etc.)

  # Synthetic Monitoring
  synthetic-tests:
    name: Synthetic Monitoring
    runs-on: ubuntu-latest
    needs: [smoke-tests]
    steps:
      - name: Run Datadog Synthetics
        if: ${{ secrets.DATADOG_API_KEY != '' }}
        run: |
          # Trigger Datadog synthetic tests
          echo "Running synthetic tests..."

      - name: Lighthouse Production Audit
        uses: treosh/lighthouse-ci-action@v10
        with:
          urls: |
            ${{ secrets.PROD_URL }}
            ${{ secrets.PROD_URL }}/tickets
            ${{ secrets.PROD_URL }}/admin
          uploadArtifacts: true
          temporaryPublicStorage: true

  # Rollback on Failure
  rollback:
    name: Rollback Production Deployment
    runs-on: ubuntu-latest
    needs: [deploy-production, smoke-tests]
    if: failure()
    environment:
      name: production
    steps:
      - name: Notify team of failure
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "üö® PRODUCTION DEPLOYMENT FAILED",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*CRITICAL: Production Deployment Failed*\n\n‚ö†Ô∏è Smoke tests failed. Manual intervention required.\n\nVersion: ${{ needs.build-and-push.outputs.version }}\nCommit: ${{ github.sha }}\nAuthor: ${{ github.actor }}\n\nWorkflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create incident
        if: ${{ secrets.PAGERDUTY_TOKEN != '' }}
        run: |
          # Create PagerDuty incident
          curl -X POST https://api.pagerduty.com/incidents \
            -H 'Authorization: Token token=${{ secrets.PAGERDUTY_TOKEN }}' \
            -H 'Content-Type: application/json' \
            -d '{
              "incident": {
                "type": "incident",
                "title": "Production deployment failed",
                "service": {
                  "id": "${{ secrets.PAGERDUTY_SERVICE_ID }}",
                  "type": "service_reference"
                },
                "urgency": "high",
                "body": {
                  "type": "incident_body",
                  "details": "Production deployment failed smoke tests. Version: ${{ needs.build-and-push.outputs.version }}"
                }
              }
            }'

      - name: Automatic rollback (if enabled)
        if: ${{ secrets.AUTO_ROLLBACK == 'true' }}
        run: |
          echo "Auto-rollback is enabled. Rolling back to previous version..."
          # Add rollback logic here

  # Success Notification
  notify-success:
    name: Notify Deployment Success
    runs-on: ubuntu-latest
    needs: [deploy-production, smoke-tests, synthetic-tests]
    if: success()
    steps:
      - name: Notify Slack
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "‚úÖ PRODUCTION DEPLOYMENT SUCCESSFUL",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment Successful* üöÄ\n\nNew version deployed and all tests passed.\n\nVersion: ${{ needs.build-and-push.outputs.version }}\nEnvironment: production\nCommit: ${{ github.sha }}\nAuthor: ${{ github.actor }}\nURL: ${{ secrets.PROD_URL }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.build-and-push.outputs.version }}
          release_name: Release ${{ needs.build-and-push.outputs.version }}
          body: |
            Production deployment successful!

            Version: ${{ needs.build-and-push.outputs.version }}
            Deployed: ${{ github.event.head_commit.timestamp }}
            Author: ${{ github.actor }}
          draft: false
          prerelease: false

      - name: Update status page
        if: ${{ secrets.STATUSPAGE_API_KEY != '' }}
        run: |
          # Update status page with new deployment
          echo "Updating status page..."
