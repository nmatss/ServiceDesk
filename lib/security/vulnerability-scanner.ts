/**
 * Vulnerability Scanning Integration
 * Automated security scanning and vulnerability detection
 */

import { spawn } from 'child_process';
import { promises as fs } from 'fs';
import { getSecurityConfig } from './config';

export interface VulnerabilityReport {
  id: string;
  scanDate: Date;
  scanType: ScanType;
  tool: string;
  status: 'running' | 'completed' | 'failed';
  summary: {
    totalVulnerabilities: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  vulnerabilities: Vulnerability[];
  recommendations: string[];
  nextScanDate?: Date;
}

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  cvss: number;
  cve?: string;
  package?: string;
  version?: string;
  fixedVersion?: string;
  category: VulnerabilityCategory;
  impact: string;
  solution: string;
  references: string[];
  firstDetected: Date;
  lastSeen: Date;
}

export enum ScanType {
  DEPENDENCY = 'dependency',
  STATIC_CODE = 'static_code',
  DYNAMIC = 'dynamic',
  CONTAINER = 'container',
  INFRASTRUCTURE = 'infrastructure'
}

export enum VulnerabilityCategory {
  INJECTION = 'injection',
  BROKEN_AUTH = 'broken_authentication',
  SENSITIVE_DATA = 'sensitive_data_exposure',
  XML_ENTITIES = 'xml_external_entities',
  BROKEN_ACCESS = 'broken_access_control',
  SECURITY_MISCONFIG = 'security_misconfiguration',
  XSS = 'cross_site_scripting',
  INSECURE_DESERIAL = 'insecure_deserialization',
  KNOWN_VULNS = 'known_vulnerabilities',
  INSUFFICIENT_LOGGING = 'insufficient_logging'
}

/**
 * Vulnerability Scanner Manager
 */
export class VulnerabilityScanner {
  private config = getSecurityConfig();
  private scanHistory: Map<string, VulnerabilityReport> = new Map();

  /**
   * Run comprehensive vulnerability scan
   */
  public async runScan(scanTypes?: ScanType[]): Promise<VulnerabilityReport> {
    const reportId = this.generateReportId();
    const types = scanTypes || [
      ScanType.DEPENDENCY,
      ScanType.STATIC_CODE,
      ScanType.DYNAMIC
    ];

    const report: VulnerabilityReport = {
      id: reportId,
      scanDate: new Date(),
      scanType: types.length === 1 ? types[0] : ScanType.DYNAMIC,
      tool: 'comprehensive',
      status: 'running',
      summary: {
        totalVulnerabilities: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      vulnerabilities: [],
      recommendations: []
    };

    this.scanHistory.set(reportId, report);

    try {
      const allVulnerabilities: Vulnerability[] = [];

      // Run each type of scan
      for (const scanType of types) {
        const vulnerabilities = await this.runSpecificScan(scanType);
        allVulnerabilities.push(...vulnerabilities);
      }

      // Deduplicate and consolidate results
      report.vulnerabilities = this.deduplicateVulnerabilities(allVulnerabilities);
      report.summary = this.calculateSummary(report.vulnerabilities);
      report.recommendations = this.generateRecommendations(report.vulnerabilities);
      report.status = 'completed';
      report.nextScanDate = this.calculateNextScanDate();

      // Send alerts for critical vulnerabilities
      await this.sendCriticalAlerts(report);

      this.logScanCompletion(report);

    } catch (error) {
      report.status = 'failed';
      console.error('Vulnerability scan failed:', error);
    }

    return report;
  }

  /**
   * Run dependency vulnerability scan
   */
  private async runDependencyScan(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Run npm audit
      const npmResults = await this.runNpmAudit();
      vulnerabilities.push(...npmResults);

      // Run Snyk if available
      if (this.config.vulnerabilityScanning.tools.includes('snyk')) {
        const snykResults = await this.runSnykScan();
        vulnerabilities.push(...snykResults);
      }

    } catch (error) {
      console.error('Dependency scan failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Run static code analysis
   */
  private async runStaticCodeScan(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Run ESLint security plugin
      const eslintResults = await this.runEslintSecurity();
      vulnerabilities.push(...eslintResults);

      // Run Semgrep if available
      const semgrepResults = await this.runSemgrep();
      vulnerabilities.push(...semgrepResults);

    } catch (error) {
      console.error('Static code scan failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Run dynamic security testing
   */
  private async runDynamicScan(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Run OWASP ZAP if available
      if (this.config.vulnerabilityScanning.tools.includes('owasp-zap')) {
        const zapResults = await this.runOwaspZap();
        vulnerabilities.push(...zapResults);
      }

      // Custom vulnerability checks
      const customResults = await this.runCustomSecurityChecks();
      vulnerabilities.push(...customResults);

    } catch (error) {
      console.error('Dynamic scan failed:', error);
    }

    return vulnerabilities;
  }

  /**
   * Run npm audit
   */
  private async runNpmAudit(): Promise<Vulnerability[]> {
    return new Promise((resolve, reject) => {
      const npmAudit = spawn('npm', ['audit', '--json'], {
        cwd: process.cwd(),
        stdio: ['ignore', 'pipe', 'pipe']
      });

      let output = '';
      let errorOutput = '';

      npmAudit.stdout.on('data', (data) => {
        output += data.toString();
      });

      npmAudit.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      npmAudit.on('close', (code) => {
        try {
          const result = JSON.parse(output);
          const vulnerabilities = this.parseNpmAuditResults(result);
          resolve(vulnerabilities);
        } catch (error) {
          if (code === 0) {
            resolve([]); // No vulnerabilities found
          } else {
            reject(new Error(`npm audit failed: ${errorOutput}`));
          }
        }
      });
    });
  }

  /**
   * Parse npm audit results
   */
  private parseNpmAuditResults(auditResult: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (auditResult.vulnerabilities) {
      for (const [packageName, vulnData] of Object.entries(auditResult.vulnerabilities as any)) {
        const vuln = vulnData as any;

        vulnerabilities.push({
          id: `npm-${packageName}-${vuln.via[0]?.cve || Date.now()}`,
          title: `${packageName}: ${vuln.via[0]?.title || 'Vulnerability'}`,
          description: vuln.via[0]?.description || 'No description available',
          severity: this.mapSeverity(vuln.severity),
          cvss: vuln.via[0]?.cvss?.score || 0,
          cve: vuln.via[0]?.cve,
          package: packageName,
          version: vuln.via[0]?.range,
          fixedVersion: vuln.fixAvailable?.version,
          category: VulnerabilityCategory.KNOWN_VULNS,
          impact: vuln.via[0]?.impact || 'Unknown',
          solution: vuln.fixAvailable ? `Update to ${vuln.fixAvailable.version}` : 'No fix available',
          references: vuln.via[0]?.url ? [vuln.via[0].url] : [],
          firstDetected: new Date(),
          lastSeen: new Date()
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Run Snyk scan
   */
  private async runSnykScan(): Promise<Vulnerability[]> {
    return new Promise((resolve, reject) => {
      const snyk = spawn('snyk', ['test', '--json'], {
        cwd: process.cwd(),
        stdio: ['ignore', 'pipe', 'pipe']
      });

      let output = '';
      let errorOutput = '';

      snyk.stdout.on('data', (data) => {
        output += data.toString();
      });

      snyk.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      snyk.on('close', (code) => {
        try {
          const result = JSON.parse(output);
          const vulnerabilities = this.parseSnykResults(result);
          resolve(vulnerabilities);
        } catch (error) {
          resolve([]); // Snyk not available or no vulnerabilities
        }
      });
    });
  }

  /**
   * Parse Snyk results
   */
  private parseSnykResults(snykResult: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (snykResult.vulnerabilities) {
      snykResult.vulnerabilities.forEach((vuln: any) => {
        vulnerabilities.push({
          id: `snyk-${vuln.id}`,
          title: vuln.title,
          description: vuln.description,
          severity: this.mapSeverity(vuln.severity),
          cvss: vuln.cvssScore || 0,
          cve: vuln.identifiers?.CVE?.[0],
          package: vuln.packageName,
          version: vuln.version,
          fixedVersion: vuln.fixedIn?.[0],
          category: this.mapSnykCategory(vuln.type),
          impact: vuln.description,
          solution: vuln.fixedIn?.[0] ? `Update to ${vuln.fixedIn[0]}` : 'No fix available',
          references: vuln.references || [],
          firstDetected: new Date(),
          lastSeen: new Date()
        });
      });
    }

    return vulnerabilities;
  }

  /**
   * Run ESLint security plugin
   */
  private async runEslintSecurity(): Promise<Vulnerability[]> {
    // This would integrate with ESLint security plugins
    // For now, return empty array
    return [];
  }

  /**
   * Run Semgrep static analysis
   */
  private async runSemgrep(): Promise<Vulnerability[]> {
    // This would integrate with Semgrep
    // For now, return empty array
    return [];
  }

  /**
   * Run OWASP ZAP dynamic scan
   */
  private async runOwaspZap(): Promise<Vulnerability[]> {
    // This would integrate with OWASP ZAP
    // For now, return empty array
    return [];
  }

  /**
   * Run custom security checks
   */
  private async runCustomSecurityChecks(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for common security misconfigurations
    await this.checkSecurityHeaders(vulnerabilities);
    await this.checkPasswordPolicies(vulnerabilities);
    await this.checkCorsConfiguration(vulnerabilities);
    await this.checkCspConfiguration(vulnerabilities);

    return vulnerabilities;
  }

  /**
   * Check security headers
   */
  private async checkSecurityHeaders(vulnerabilities: Vulnerability[]): Promise<void> {
    // This would check the application's security headers
    // Implementation would test actual HTTP responses
  }

  /**
   * Check password policies
   */
  private async checkPasswordPolicies(vulnerabilities: Vulnerability[]): Promise<void> {
    // Check if strong password policies are enforced
    const hasWeakPasswordPolicy = !process.env.MIN_PASSWORD_LENGTH ||
                                  parseInt(process.env.MIN_PASSWORD_LENGTH) < 8;

    if (hasWeakPasswordPolicy) {
      vulnerabilities.push({
        id: 'weak-password-policy',
        title: 'Weak Password Policy',
        description: 'Password policy does not meet security requirements',
        severity: 'medium',
        cvss: 5.0,
        category: VulnerabilityCategory.BROKEN_AUTH,
        impact: 'Users may choose weak passwords, increasing risk of account compromise',
        solution: 'Implement strong password requirements (minimum 8 characters, complexity rules)',
        references: ['https://owasp.org/www-project-authentication-cheat-sheet/'],
        firstDetected: new Date(),
        lastSeen: new Date()
      });
    }
  }

  /**
   * Check CORS configuration
   */
  private async checkCorsConfiguration(vulnerabilities: Vulnerability[]): Promise<void> {
    // Check for overly permissive CORS settings
    const corsOrigins = this.config.cors.allowedOrigins;

    if (corsOrigins.includes('*')) {
      vulnerabilities.push({
        id: 'permissive-cors',
        title: 'Overly Permissive CORS Configuration',
        description: 'CORS allows all origins (*)',
        severity: 'medium',
        cvss: 4.0,
        category: VulnerabilityCategory.SECURITY_MISCONFIG,
        impact: 'May allow unauthorized cross-origin requests',
        solution: 'Configure specific allowed origins instead of wildcard',
        references: ['https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny'],
        firstDetected: new Date(),
        lastSeen: new Date()
      });
    }
  }

  /**
   * Check CSP configuration
   */
  private async checkCspConfiguration(vulnerabilities: Vulnerability[]): Promise<void> {
    // Check for unsafe CSP directives
    const cspDirectives = this.config.csp.directives;

    const hasUnsafeInline = Object.values(cspDirectives).some(directive =>
      Array.isArray(directive) && directive.includes("'unsafe-inline'")
    );

    if (hasUnsafeInline && process.env.NODE_ENV === 'production') {
      vulnerabilities.push({
        id: 'unsafe-csp',
        title: 'Unsafe CSP Configuration',
        description: 'Content Security Policy allows unsafe-inline',
        severity: 'medium',
        cvss: 4.5,
        category: VulnerabilityCategory.XSS,
        impact: 'Reduces protection against XSS attacks',
        solution: 'Remove unsafe-inline directives and use nonces or hashes',
        references: ['https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP'],
        firstDetected: new Date(),
        lastSeen: new Date()
      });
    }
  }

  /**
   * Helper methods
   */
  private async runSpecificScan(scanType: ScanType): Promise<Vulnerability[]> {
    switch (scanType) {
      case ScanType.DEPENDENCY:
        return this.runDependencyScan();
      case ScanType.STATIC_CODE:
        return this.runStaticCodeScan();
      case ScanType.DYNAMIC:
        return this.runDynamicScan();
      default:
        return [];
    }
  }

  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set<string>();
    return vulnerabilities.filter(vuln => {
      const key = `${vuln.package || 'unknown'}-${vuln.cve || vuln.title}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  private calculateSummary(vulnerabilities: Vulnerability[]) {
    const summary = {
      totalVulnerabilities: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };

    vulnerabilities.forEach(vuln => {
      summary[vuln.severity]++;
    });

    return summary;
  }

  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];

    const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;

    if (criticalCount > 0) {
      recommendations.push(`Immediately address ${criticalCount} critical vulnerabilities`);
    }

    if (highCount > 0) {
      recommendations.push(`Address ${highCount} high-severity vulnerabilities within 24-48 hours`);
    }

    // Package-specific recommendations
    const packageVulns = vulnerabilities.filter(v => v.package);
    if (packageVulns.length > 0) {
      recommendations.push('Update vulnerable dependencies to latest secure versions');
    }

    return recommendations;
  }

  private calculateNextScanDate(): Date {
    const frequency = this.config.vulnerabilityScanning.scanFrequency;
    const nextScan = new Date();

    switch (frequency) {
      case 'daily':
        nextScan.setDate(nextScan.getDate() + 1);
        break;
      case 'weekly':
        nextScan.setDate(nextScan.getDate() + 7);
        break;
      case 'monthly':
        nextScan.setMonth(nextScan.getMonth() + 1);
        break;
      default:
        nextScan.setDate(nextScan.getDate() + 7);
    }

    return nextScan;
  }

  private async sendCriticalAlerts(report: VulnerabilityReport): Promise<void> {
    const criticalVulns = report.vulnerabilities.filter(v => v.severity === 'critical');

    if (criticalVulns.length > 0 && this.config.monitoring.alerting.enabled) {
      // Send alerts via configured channels
      console.warn(`CRITICAL SECURITY ALERT: ${criticalVulns.length} critical vulnerabilities found`);

      // TODO: Implement actual alerting (email, Slack, webhook, etc.)
    }
  }

  private mapSeverity(severity: string): 'critical' | 'high' | 'medium' | 'low' {
    switch (severity.toLowerCase()) {
      case 'critical':
        return 'critical';
      case 'high':
        return 'high';
      case 'moderate':
      case 'medium':
        return 'medium';
      case 'low':
      case 'info':
        return 'low';
      default:
        return 'medium';
    }
  }

  private mapSnykCategory(type: string): VulnerabilityCategory {
    switch (type.toLowerCase()) {
      case 'license':
        return VulnerabilityCategory.KNOWN_VULNS;
      default:
        return VulnerabilityCategory.KNOWN_VULNS;
    }
  }

  private generateReportId(): string {
    return `vuln_scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private logScanCompletion(report: VulnerabilityReport): void {
    console.log('Vulnerability scan completed:', {
      reportId: report.id,
      scanDate: report.scanDate,
      status: report.status,
      summary: report.summary
    });
  }

  /**
   * Get scan history
   */
  public getScanHistory(): VulnerabilityReport[] {
    return Array.from(this.scanHistory.values()).sort(
      (a, b) => b.scanDate.getTime() - a.scanDate.getTime()
    );
  }

  /**
   * Get specific scan report
   */
  public getScanReport(reportId: string): VulnerabilityReport | undefined {
    return this.scanHistory.get(reportId);
  }
}

/**
 * Vulnerability Scanner Automation
 */
export class VulnerabilityAutomation {
  private scanner = new VulnerabilityScanner();

  /**
   * Start automated vulnerability scanning
   */
  public startAutomation(): void {
    const config = getSecurityConfig();

    if (!config.vulnerabilityScanning.enabled) {
      console.log('Vulnerability scanning automation is disabled');
      return;
    }

    // Schedule regular scans
    this.scheduleRegularScans();

    // Monitor for dependency changes
    this.monitorDependencyChanges();
  }

  private scheduleRegularScans(): void {
    const frequency = getSecurityConfig().vulnerabilityScanning.scanFrequency;

    // TODO: Implement actual scheduling (cron, setInterval, etc.)
    console.log(`Scheduled vulnerability scans: ${frequency}`);
  }

  private monitorDependencyChanges(): void {
    // TODO: Monitor package.json changes and trigger scans
    console.log('Monitoring dependency changes for automatic scanning');
  }
}