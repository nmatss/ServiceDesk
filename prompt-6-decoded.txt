# PROMPT: Implementa√ß√£o e An√°lise de Seguran√ßa do Stack Auth

## üéØ OBJETIVO
Implementar e analisar a seguran√ßa do Stack Auth em projetos Next.js com foco em autentica√ß√£o robusta, prote√ß√£o de rotas, gerenciamento de sess√µes e auditoria de seguran√ßa. Este prompt fornece um guia completo para implementa√ß√£o segura do Stack Auth com Neon Database.

## üö® VERIFICA√á√ïES CR√çTICAS OBRIGAT√ìRIAS

### ‚ö†Ô∏è ANTES de implementar, execute estas verifica√ß√µes para evitar vulnerabilidades:

```bash
# 1. Verificar vers√£o do Stack Auth (CR√çTICO para seguran√ßa)
npm list @stackframe/stack

# 2. Verificar vari√°veis de ambiente de seguran√ßa
echo "Verificando vari√°veis cr√≠ticas..."
[ -z "$STACK_SECRET_SERVER_KEY" ] && echo "‚ùå STACK_SECRET_SERVER_KEY n√£o configurado"
[ -z "$NEXT_PUBLIC_STACK_PROJECT_ID" ] && echo "‚ùå NEXT_PUBLIC_STACK_PROJECT_ID n√£o configurado"
[ -z "$DATABASE_URL" ] && echo "‚ùå DATABASE_URL n√£o configurado"

# 3. Verificar tipos TypeScript (OBRIGAT√ìRIO)
npx tsc --noEmit

# 4. Testar build de produ√ß√£o
npm run build

# 5. Verificar configura√ß√£o de CORS
curl -I https://stack-auth.com/api/v1/projects/YOUR_PROJECT_ID
```

### üîß CORRE√á√ïES CR√çTICAS DE SEGURAN√áA:

#### 1. Prote√ß√£o contra Session Fixation
**Problema**: Sess√µes n√£o s√£o renovadas ap√≥s login
**Solu√ß√£o**: Implementar renova√ß√£o de sess√£o

```tsx
// ‚ùå INCORRETO - Vulner√°vel a session fixation
const handleLogin = async (credentials: LoginCredentials) => {
  const result = await signIn(credentials);
  // Sess√£o n√£o √© renovada
  return result;
};

// ‚úÖ CORRETO - Sess√£o renovada ap√≥s login
const handleLogin = async (credentials: LoginCredentials) => {
  const result = await signIn(credentials);
  if (result.success) {
    // For√ßar renova√ß√£o da sess√£o
    await stackServerApp.refreshSession();
  }
  return result;
};
```

#### 2. Valida√ß√£o de Entrada Segura
**Problema**: Dados do usu√°rio n√£o s√£o validados
**Solu√ß√£o**: Usar Zod para valida√ß√£o

```tsx
// ‚ùå INCORRETO - Sem valida√ß√£o
const updateProfile = async (data: any) => {
  await sql`UPDATE users SET name = ${data.name} WHERE id = ${userId}`;
};

// ‚úÖ CORRETO - Com valida√ß√£o Zod
import { z } from 'zod';

const profileSchema = z.object({
  name: z.string().min(1).max(100).trim(),
  email: z.string().email(),
  phone: z.string().optional()
});

const updateProfile = async (data: unknown) => {
  const validatedData = profileSchema.parse(data);
  await sql`UPDATE users SET name = ${validatedData.name} WHERE id = ${userId}`;
};
```

#### 3. Prote√ß√£o CSRF em Formul√°rios
**Problema**: Formul√°rios vulner√°veis a CSRF
**Solu√ß√£o**: Implementar tokens CSRF

```tsx
// ‚ùå INCORRETO - Sem prote√ß√£o CSRF
<form action="/api/update-profile" method="POST">
  <input name="name" value={user.name} />
  <button type="submit">Update</button>
</form>

// ‚úÖ CORRETO - Com prote√ß√£o CSRF
import { generateCSRFToken } from '@/lib/csrf';

const ProfileForm = () => {
  const csrfToken = generateCSRFToken();
  
  return (
    <form action="/api/update-profile" method="POST">
      <input type="hidden" name="csrf_token" value={csrfToken} />
      <input name="name" value={user.name} />
      <button type="submit">Update</button>
    </form>
  );
};
```

#### 4. Rate Limiting para APIs
**Problema**: APIs vulner√°veis a ataques de for√ßa bruta
**Solu√ß√£o**: Implementar rate limiting

```tsx
// ‚ùå INCORRETO - Sem rate limiting
export async function POST(request: NextRequest) {
  const { email, password } = await request.json();
  return await signIn(email, password);
}

// ‚úÖ CORRETO - Com rate limiting
import { rateLimit } from '@/lib/rate-limit';

export async function POST(request: NextRequest) {
  const ip = request.ip || 'unknown';
  
  // Limitar a 5 tentativas por minuto
  const { success } = await rateLimit.limit(ip);
  if (!success) {
    return NextResponse.json({ error: 'Too many attempts' }, { status: 429 });
  }
  
  const { email, password } = await request.json();
  return await signIn(email, password);
}
```

## üìã PR√â-REQUISITOS

### Depend√™ncias de Seguran√ßa:
```bash
# Instalar Stack Auth e depend√™ncias de seguran√ßa
npm install @stackframe/stack zod bcrypt helmet
npm install -D @types/bcrypt

# Instalar depend√™ncias para auditoria
npm install @neondatabase/serverless jose
```

### Estrutura de Arquivos Segura:
```
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts              # Configura√ß√£o Stack Auth
‚îÇ   ‚îú‚îÄ‚îÄ security.ts          # Utilit√°rios de seguran√ßa
‚îÇ   ‚îú‚îÄ‚îÄ rate-limit.ts        # Rate limiting
‚îÇ   ‚îú‚îÄ‚îÄ csrf.ts              # Prote√ß√£o CSRF
‚îÇ   ‚îî‚îÄ‚îÄ audit.ts             # Logs de auditoria
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts              # Middleware de autentica√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ security.ts          # Middleware de seguran√ßa
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/            # Rotas de autentica√ß√£o
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ audit/           # Rotas de auditoria
‚îÇ   ‚îî‚îÄ‚îÄ (auth)/              # P√°ginas de autentica√ß√£o
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ auth/                # Componentes de autentica√ß√£o
    ‚îî‚îÄ‚îÄ security/            # Componentes de seguran√ßa
```

## üöÄ IMPLEMENTA√á√ÉO SEGURA DO STACK AUTH

### 1. Configura√ß√£o Base de Seguran√ßa (stack.tsx):

```tsx
import { StackServerApp } from "@stackframe/stack";

export const stackServerApp = new StackServerApp({
  tokenStore: "nextjs-cookie",
  urls: {
    signIn: "/auth/sign-in",
    signUp: "/auth/sign-up",
    emailVerification: "/auth/email-verification",
    passwordReset: "/auth/password-reset",
    home: "/dashboard",
    afterSignIn: "/dashboard",
    afterSignUp: "/auth/setup-profile",
    afterEmailVerification: "/dashboard",
    afterPasswordReset: "/dashboard",
  },
  // Configura√ß√µes de seguran√ßa
  cookies: {
    secure: process.env.NODE_ENV === "production",
    httpOnly: true,
    sameSite: "strict",
    maxAge: 24 * 60 * 60 * 1000, // 24 horas
  },
});
```

### 2. Middleware de Seguran√ßa (middleware.ts):

```tsx
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { stackServerApp } from "@/stack";

// Rotas protegidas
const protectedRoutes = [
  "/dashboard",
  "/admin",
  "/profile",
  "/api/protected",
];

// Rotas de autentica√ß√£o
const authRoutes = [
  "/auth/sign-in",
  "/auth/sign-up",
  "/auth/password-reset",
];

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Headers de seguran√ßa
  const response = NextResponse.next();
  response.headers.set("X-Content-Type-Options", "nosniff");
  response.headers.set("X-Frame-Options", "DENY");
  response.headers.set("X-XSS-Protection", "1; mode=block");
  response.headers.set("Referrer-Policy", "strict-origin-when-cross-origin");
  
  // Verificar autentica√ß√£o para rotas protegidas
  if (protectedRoutes.some(route => pathname.startsWith(route))) {
    const user = await stackServerApp.getUser({ or: "return-null" });
    
    if (!user) {
      return NextResponse.redirect(new URL("/auth/sign-in", request.url));
    }
    
    // Log de acesso para auditoria
    await logAccess(user.id, pathname, request.ip);
  }
  
  // Redirecionar usu√°rios autenticados de p√°ginas de auth
  if (authRoutes.some(route => pathname.startsWith(route))) {
    const user = await stackServerApp.getUser({ or: "return-null" });
    
    if (user) {
      return NextResponse.redirect(new URL("/dashboard", request.url));
    }
  }
  
  return response;
}

// Fun√ß√£o de log de auditoria
async function logAccess(userId: string, path: string, ip?: string) {
  try {
    const sql = neon(process.env.DATABASE_URL!);
    await sql`
      INSERT INTO audit_logs (user_id, action, path, ip_address, timestamp)
      VALUES (${userId}, 'access', ${path}, ${ip || 'unknown'}, NOW())
    `;
  } catch (error) {
    console.error("Erro ao registrar log de auditoria:", error);
  }
}

export const config = {
  matcher: [
    "/((?!api|_next/static|_next/image|favicon.ico).*)",
  ],
};
```

### 3. Prote√ß√£o de Rotas API (api/protected/route.ts):

```tsx
import { NextRequest, NextResponse } from "next/server";
import { stackServerApp } from "@/stack";
import { z } from "zod";

// Schema de valida√ß√£o
const requestSchema = z.object({
  action: z.enum(["create", "update", "delete"]),
  data: z.object({
    id: z.string().optional(),
    title: z.string().min(1).max(255),
    description: z.string().max(1000).optional(),
  }),
});

export async function POST(request: NextRequest) {
  try {
    // Verificar autentica√ß√£o
    const user = await stackServerApp.getUser({ or: "return-null" });
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    
    // Validar entrada
    const body = await request.json();
    const validatedData = requestSchema.parse(body);
    
    // Verificar permiss√µes espec√≠ficas
    if (validatedData.action === "delete" && !user.serverMetadata?.isAdmin) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }
    
    // Log de auditoria
    await logUserAction(user.id, validatedData.action, validatedData.data);
    
    // Processar requisi√ß√£o
    const result = await processRequest(validatedData);
    
    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: "Invalid data", details: error.errors }, { status: 400 });
    }
    
    console.error("API Error:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

async function logUserAction(userId: string, action: string, data: any) {
  try {
    const sql = neon(process.env.DATABASE_URL!);
    await sql`
      INSERT INTO audit_logs (user_id, action, data, timestamp)
      VALUES (${userId}, ${action}, ${JSON.stringify(data)}, NOW())
    `;
  } catch (error) {
    console.error("Erro ao registrar a√ß√£o:", error);
  }
}

async function processRequest(data: any) {
  // Implementar l√≥gica de neg√≥cio aqui
  return { processed: true, timestamp: new Date().toISOString() };
}
```

### 4. Componente de Auditoria (components/security/AuditLog.tsx):

```tsx
'use client';

import { useState, useEffect } from 'react';
import { useUser } from '@stackframe/stack';

interface AuditEntry {
  id: string;
  user_id: string;
  action: string;
  path?: string;
  data?: any;
  ip_address?: string;
  timestamp: string;
}

export default function AuditLog() {
  const user = useUser({ or: "redirect" });
  const [logs, setLogs] = useState<AuditEntry[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('all');

  useEffect(() => {
    if (user?.serverMetadata?.isAdmin) {
      fetchAuditLogs();
    }
  }, [user, filter]);

  const fetchAuditLogs = async () => {
    try {
      setLoading(true);
      const response = await fetch(`/api/audit/logs?filter=${filter}`);
      const data = await response.json();
      setLogs(data.logs);
    } catch (error) {
      console.error('Erro ao buscar logs:', error);
    } finally {
      setLoading(false);
    }
  };

  if (!user?.serverMetadata?.isAdmin) {
    return <div>Acesso negado</div>;
  }

  return (
    <div className="bg-white shadow rounded-lg">
      <div className="px-4 py-5 sm:p-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Logs de Auditoria
        </h3>
        
        {/* Filtros */}
        <div className="mb-4">
          <select
            value={filter}
            onChange={(e) => setFilter(e.target.value)}
            className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
          >
            <option value="all">Todas as a√ß√µes</option>
            <option value="access">Acessos</option>
            <option value="create">Cria√ß√µes</option>
            <option value="update">Atualiza√ß√µes</option>
            <option value="delete">Exclus√µes</option>
          </select>
        </div>

        {/* Tabela de logs */}
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Data/Hora
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Usu√°rio
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  A√ß√£o
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Detalhes
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  IP
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {logs.map((log) => (
                <tr key={log.id}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {new Date(log.timestamp).toLocaleString()}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {log.user_id}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                      log.action === 'delete' ? 'bg-red-100 text-red-800' :
                      log.action === 'create' ? 'bg-green-100 text-green-800' :
                      log.action === 'update' ? 'bg-yellow-100 text-yellow-800' :
                      'bg-blue-100 text-blue-800'
                    }`}>
                      {log.action}
                    </span>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                    {log.path || JSON.stringify(log.data)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {log.ip_address}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}
```

## ‚öôÔ∏è CONFIGURA√á√ïES DE SEGURAN√áA AVAN√áADAS

### 1. Configura√ß√£o de Rate Limiting (lib/rate-limit.ts):

```tsx
import { LRUCache } from 'lru-cache';

type Options = {
  uniqueTokenPerInterval?: number;
  interval?: number;
}

export default function rateLimit(options?: Options) {
  const tokenCache = new LRUCache({
    max: options?.uniqueTokenPerInterval || 500,
    ttl: options?.interval || 60000,
  });

  return {
    check: (limit: number, token: string) =>
      new Promise<void>((resolve, reject) => {
        const tokenCount = (tokenCache.get(token) as number[]) || [0];
        if (tokenCount[0] === 0) {
          tokenCache.set(token, tokenCount);
        }
        tokenCount[0] += 1;

        const currentUsage = tokenCount[0];
        const isRateLimited = currentUsage >= limit;

        if (isRateLimited) {
          reject(new Error('Rate limit exceeded'));
        } else {
          resolve();
        }
      }),
  };
}
```

### 2. Configura√ß√£o de CSRF (lib/csrf.ts):

```tsx
import { randomBytes } from 'crypto';

const tokens = new Map<string, number>();

export function generateCSRFToken(): string {
  const token = randomBytes(32).toString('hex');
  tokens.set(token, Date.now() + 3600000); // 1 hora
  return token;
}

export function validateCSRFToken(token: string): boolean {
  const expiry = tokens.get(token);
  if (!expiry || Date.now() > expiry) {
    tokens.delete(token);
    return false;
  }
  
  tokens.delete(token); // Token √∫nico
  return true;
}
```

### 3. Schema de Auditoria (database/audit_logs.sql):

```sql
CREATE TABLE IF NOT EXISTS audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL,
  action VARCHAR(50) NOT NULL,
  path TEXT,
  data JSONB,
  ip_address INET,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- √çndices para performance
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp);
```

## üõ†Ô∏è TROUBLESHOOTING DE SEGURAN√áA

### Problema 1: Sess√µes n√£o expiram
**Causa**: Configura√ß√£o incorreta do cookie
**Solu√ß√£o**: Configurar maxAge corretamente

### Problema 2: CSRF tokens inv√°lidos
**Causa**: Tokens n√£o sincronizados
**Solu√ß√£o**: Implementar store persistente para tokens

### Problema 3: Rate limiting n√£o funciona
**Causa**: Cache n√£o configurado
**Solu√ß√£o**: Implementar cache Redis para produ√ß√£o

### Problema 4: Logs de auditoria perdidos
**Causa**: Falha na conex√£o com banco
**Solu√ß√£o**: Implementar queue para logs cr√≠ticos

## ‚úÖ CHECKLIST FINAL DE SEGURAN√áA

### Verifica√ß√µes Obrigat√≥rias:
- [ ] **Autentica√ß√£o**: Stack Auth configurado corretamente
- [ ] **Autoriza√ß√£o**: Middleware de prote√ß√£o implementado
- [ ] **Valida√ß√£o**: Schemas Zod em todas as APIs
- [ ] **Rate Limiting**: Prote√ß√£o contra for√ßa bruta
- [ ] **CSRF**: Prote√ß√£o em formul√°rios cr√≠ticos
- [ ] **Auditoria**: Logs de seguran√ßa implementados
- [ ] **Headers**: Headers de seguran√ßa configurados
- [ ] **Vari√°veis**: Secrets configurados corretamente
- [ ] **Banco**: Conex√£o segura com Neon
- [ ] **Build**: Sem erros de TypeScript
- [ ] **Testes**: Testes de seguran√ßa executados

### Comandos de Valida√ß√£o Final:
```bash
# Verificar configura√ß√£o
npm run build
npx tsc --noEmit

# Testar autentica√ß√£o
curl -X POST http://localhost:3000/api/auth/test

# Verificar rate limiting
for i in {1..10}; do curl -X POST http://localhost:3000/api/test; done

# Testar auditoria
curl -X GET http://localhost:3000/api/audit/logs
```

## üéâ CONCLUS√ÉO

Este prompt implementa uma arquitetura de seguran√ßa robusta com Stack Auth, incluindo:
- ‚úÖ **Autentica√ß√£o segura** com renova√ß√£o de sess√µes
- ‚úÖ **Prote√ß√£o contra ataques** (CSRF, XSS, for√ßa bruta)
- ‚úÖ **Auditoria completa** de a√ß√µes dos usu√°rios
- ‚úÖ **Valida√ß√£o rigorosa** de dados de entrada
- ‚úÖ **Monitoramento** de seguran√ßa em tempo real

**Mantenha sempre as depend√™ncias atualizadas e monitore os logs de seguran√ßa regularmente!** 